\input wbox
\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename act
@settitle ACT
@setchapternewpage odd
@paragraphindent 0
@c
@c %**end of header

@c ------------------------------------------------------------------------
@c  Copyright notice
@c ------------------------------------------------------------------------

@ifinfo
This document describes the language used by the Asynchronous Circuit
Toolkit (ACT), and how to write new tools that understand this
language using the standard ACT library.

Copyright @copyright{} 2004-2018 Rajit Manohar

All Rights Reserved.
@end ifinfo

@c ------------------------------------------------------------------------
@c  Title page
@c ------------------------------------------------------------------------

@titlepage
@title ACT
@subtitle Language description and libraries
@author Rajit Manohar

@c ------------------------------------------------------------------------
@c  Copyright notice
@c ------------------------------------------------------------------------

@page
@vskip 0pt plus 1filll
This document describes the language used by the Asynchronous Circuit
Toolkit (@sc{act}), and how to write new tools that understand this
language using the standard @sc{act} library.

@vskip 1cm

Copyright @copyright{} 2004-2018 Rajit Manohar

All Rights Reserved.
@end titlepage

@c ------------------------------------------------------------------------
@c   Top node
@c ------------------------------------------------------------------------

@ifinfo
@node    Top, Introduction, (dir), (dir)

This document describes the language used by the Asynchronous
Circuit Toolkit, and how to write new tools that understand this
language using the standard @sc{act} library.

@menu
Select a chapter using the `m' key

* Introduction::        A brief introduction to the circuit description
        		language, including some simple examples.

* Types::               The care and feeding of type definitions.

* Expressions::         The syntax of expressions.

* Connections::         Aliasing and initialization.

* Control Flow::        Looping and IF constructs for circuit construction.

* Namespaces::          The care and feeding of namespaces.

* Languages::           Various languages, including CHP, PRS, and HSE.

* API::                 C++ API to use the @sc{act} library

Appendices.

* BNF::                 BNF for the @sc{act} language.
* Errors and Warnings:: Index of errors and warnings printed by the @sc{act}
			library.
* Function Index::      Index of functions that are part of the @sc{act} library.
* Concept Index::       Index of concepts.

@end menu

@end ifinfo

@contents

@c ------------------------------------------------------------------------
@c     Introduction
@c ------------------------------------------------------------------------

@node Introduction,  Simple example, Top, Top
@comment node-name, next, previous, up

@chapter A Tutorial Introduction

@cindex @sc{act}, language
@cindex @sc{act}, introduction

The Asynchronous Circuit Toolkit (@sc{act}) is a suite of programs that can be
used to design, verify, and test asynchronous circuits.  The tools share
a common input language---@sc{act}---which can be used to describe
circuits at different levels of detail. In what follows, we assume that
the reader is familiar with asynchronous design methodologies and
terminology.

@sc{act} is a hierarchical, lexically scoped circuit description
language. A single @sc{act} file can be used to describe the transistor
implementation of a circuit as well as a high-level functional
description of the same circuit.

There are three parts to @sc{act}---reading in an @sc{act} file, an
elaboration phase where parameters are expanded, and finally a circuit
construction and instantiation phase. In the parsing phase, the input
is converted into internal data structures. In the expansion phase,
parameters are substituted, creating a concrete hierarchical
netlist. In the instantiation phase, data structures are created for
every circuit element specified in the @sc{act} file. Errors may be
reported in any of these stages. As a rule of thumb, errors are
reported as soon as there is sufficient information to determine the
error.

@menu
* Simple example::      A simple example of how @sc{act} can be used.
* Variables and expressions:: 
                        Variable and expression syntax.
* Arrays::              Array constructs.
* Loops and Conditionals::
                        Ways to handle control flow.
* Scoping::             Scoping conventions.
* Intro to Namespaces:: Namespace summary.
* Importing files::     Using multiple files.
@end menu

@c ------------------------------------------------------------------------
@c   Simple example
@c ------------------------------------------------------------------------
@node Simple example,  Variables and expressions, Introduction, Introduction
@comment  node-name,  next,  previous,  up

@section A Simple Example

To get a feel for how a circuit is described in @sc{act}, we begin
with a simple example circuit. The purpose of this circuit is to
create a dual rail channel (called @code{a1of2} for a one-of-two
encoded data channel and an acknowledge) and attach a bit-bucket to
it.

@example
/* my first act program */
defchan a1of2 <: chan(bool) (bool d0,d1,a)
@{
  spec @{
    exclhi(d0,d1)  // @r{exclusive high directive}
  @}
  // @r{channel description omitted}
@}
  
defproc bitbucket (a1of2 d)
@{
  prs @{
    d.d0 | d.d1  -> d.a+
   ~d.d0 & ~d.d1 -> d.a-
  @}
@}

bitbucket b;
a1of2 c;

b.d = c;
@end example

@cindex bool
@cindex chan
@cindex exclhi
@cindex ports

@code{defchan a1of2} is used to create a new channel type named
@code{a1of2} with a port list that consists of three Boolean values
named @code{d0}, @code{d1}, and @code{a}. A @code{bool} is a
Boolean-valued electrical node in the circuit, and is a built-in
type. Identifier names such as @code{d0} and @code{a1of2} conform to
the C naming convention. The @dfn{body} of the type @code{a1of2} is
enclosed in braces.

The @code{defchan} construct specifies that @code{a1of2} is a channel
type, and the signature @w{``@code{<: chan(bool)}''} is used to
specify that @code{a1of2} is an implementation of a channel of type
@code{chan(bool)}. Boolean-valued variables can be sent or received on
this channel since the type of the value communicated on the
@code{chan} that it implements is @code{bool}. @code{chan} is also a
built-in type that is used for communication channels.

@cindex type, body
@cindex body, language-specific
@cindex defproc
@cindex defchan
@cindex @code{spec} body
@cindex body, @code{spec}
@cindex specification body

The definition of type @code{a1of2} consists of a @code{spec}
body. The construct @w{@var{name} @code{@{ @dots{}  @}}} is used to
specify a @dfn{language-specific body} within a type definition. A
type can have any number of these language-specific bodies. A program
using the @sc{act} library typically will examine a subset of all
possible language bodies. In our example, the word @code{spec} is
recognized to be a @dfn{specification} body.

The specification body contains an assertion indicating that the nodes 
@code{d0} and @code{d1} are exclusive high, meaning that
@iftex 
@tex
$\neg \hbox{\tt d0} \vee \neg \hbox{\tt d1}$
@end tex
@end iftex
@ifinfo 
(~d0|~d1)
@end ifinfo
is an invariant of the system. Whenever a circuit element of type
@code{a1of2} is created, this specification will be automatically
attached to it. Tools that read @sc{act} files can use this
information for a variety of purposes, and can also check if this
invariant is violated in case of an error in the design of a circuit
that uses this channel.

@cindex production rules
@cindex @code{prs} body
@cindex body, @code{prs}

The process @code{bitbucket} is defined to take a variable @code{d} of
type @code{a1of2} as its argument. @code{bitbucket} is a process
rather than a channel because it was created using @code{defproc}
instead of @code{defchan}. The body of @code{bitbucket} contains a
different language-specific body, namely a @code{prs} body. @code{prs}
bodies correspond to @dfn{production rule set} descriptions of the
process. In the example, the production rules for @code{bitbucket}
corresponds to what is commonly referred to as a ``bit-bucket'' or a
``token sink'' for a four phase dual rail channel.

@cindex dot notation
@cindex type, fields of
@cindex instantiation

The statement @code{bitbucket b} creates an @dfn{instance} of type
@code{bitbucket} named @code{b}. The statement is said to be an
@dfn{instantiation}. Execution of this statement creates variable
@code{b} of type @code{bitbucket}, production rules corresponding to
the body of a @code{bitbucket}, and the specification body for the
@code{a1of2} variable @code{b.d}. Similarly, the statement @code{a1of2
d} creates an instance of type @code{a1of2}. @sc{act} uses the
standard dot-notation to access the names that are in port lists,
since they are analogous to the fields of types in conventional
programming languages.

@cindex connections

The final statement @code{b.d=c} @dfn{connects} the two @code{a1of2}
types @code{b.d} and @code{c}. The effect of connecting two types is
to make the two instances aliases for each other. Therefore, the
connect statement also specifies that the Booleans @code{b.d.d0},
@code{b.d.d1}, @code{b.d.a} are the same as the Booleans @code{d.d0},
@code{d.d1}, @code{d.a} respectively. Electrically, those Booleans
correspond to the same circuit node.

@sc{act} recognizes both C and C++ style comments, and they are treated
as white space along with spaces, tabs, and new lines. A C-style comment
begins with the characters @code{/*} and ends with @code{*/}. Everything
between the beginning and end of the comment is treated as
whitespace. A C++-style comment begins with @code{//} and continues till
the end of line.

@c ------------------------------------------------------------------------

@node Variables and expressions,  Arrays, Simple example, Introduction
@comment  node-name,  next,  previous,  up

@section Variables and Expressions

@cindex ports
@cindex circuit element
@cindex variables
@cindex variables, integer
@cindex variables, floating-point
@cindex variables, real
@cindex variables, boolean
@cindex type, user-defined

Variables in @sc{act} fall into two basic categories: @dfn{parameters}
and @dfn{circuit elements}. A parameter is a variable that is used to
parameterize a circuit element in some way and must be of type integer
(@code{pint} for unsigned integer or @code{pints} for signed integer),
real (@code{preal}), or Boolean (@code{pbool}). Circuit elements
consist of Booleans (@code{bool}), integers (@code{int}), or channels
(@code{chan}).

@cindex identifier, lexical conventions

A variable identifier can be a sequence of digits, letters, and
underscores. The following declarations are
legal:

@example
bitbucket b;
a1of2 x1;
a1of2 _2;
bool x5;
@end example
@noindent
On the other hand, the following declaration is incorrect.

@kindex Expecting bnf-item `@var{item}', got `@var{item}'

@example
pbool 5;
@result{} @error{} Expecting bnf-item `instance_id', got `5'
@end example

Errors use names from the @sc{act} BNF to describe the item that the
parser was expecting. Error messages are accompanied by the file name,
line number, and column number of the item that resulted in the error.

The names in the port list of a user-defined type are the only parts of
the type that are visible externally. Other parts of the defined type
cannot be accessed outside the body of the type itself. For example,
consider the following definition of @code{bitbucket}.

@example
defproc bitbucket(a1of2 d)
@{
  bool p;
  prs @{
    d.d0 | d.d1  -> d.a+
   ~d.d0 & ~d.d1 -> d.a-
  @}
@}
@end example

@noindent
If we had used this definition, then although @code{b.p} is a @code{bool}
within the bit-bucket @code{b}, we cannot access it by statements
outside the body. Therefore, a statement such as @code{b.p=c.d0} would
result in the following message:

@kindex `@var{var}' is not a port for `@var{type}'

@example
bitbucket b;
a1of2 c;
b.p = c.d0;
@result{} @error{} `p' is not a port for `bitbucket'
@end example

@cindex expressions, numeric
@cindex expressions, logical
@cindex expressions, boolean
@cindex comparison

Expressions look very much like C expressions. Expressions can be of two
types: numeric or logical. Numeric expressions can be constructed from
identifiers, numeric constants, parentheses for grouping, and the
arithmetic operators @code{+}, @code{-}, @code{*}, and @code{/} for
addition, subtraction, multiplication, and division respectively. The
unary minus operator is also supported. The operator @code{%} is used
for computing the remainder. Logical expressions can be constructed from
logical variables, the logical constants @code{true} and @code{false},
and the logical operators @code{&}, @code{|}, and @code{~} denoting
the and, or, and negation operations respectively.  Numeric expressions
can be compared using @code{<}, @code{<=}, @code{>}, @code{>=},
@code{=}, and @code{!=} for the operators less than, less than or equal
to, greater than, greater than or equal to, equal to, and not equal to
respectively.

@c ------------------------------------------------------------------------

@node  Arrays,  Loops and Conditionals, Variables and expressions, Introduction
@comment  node-name,  next,  previous,  up

@section Arrays

@cindex array
@cindex array, instantiation

Most circuits contain a set of components that are replicated a number
of times. This is especially common in datapath circuits. @sc{act} has a
very flexible array mechanism that can be used to construct complex
circuits. The simplest way to create an array is shown below.

@example
bool x[10];
a1of2 y[5][3];
@end example

The first statement creates an array of ten @code{bool}s named @code{x} whose
elements are @code{x[0]}, @code{x[1]}, @dots{}, @code{x[9]}. The
second statement creates a two-dimensional array of @code{a1of2}
variables named @code{y} whose elements are @code{y[0][0]},
@code{y[0][1]}, @dots{}, @code{y[4][2]}. The entire array range can also
be specified as shown below

@example
bool w[4..7]; // @r{create Booleans @t{w[4]}, @dots{}, @t{w[7]}}
@end example

@sc{act} also contains a mechanism for constructing @dfn{sparse
arrays}. A sparse array is one that has ``holes'' in it; in other words,
valid indices of the array do not form a contiguous, rectangular
block. Consider the following instantiation:

@example
bool x[10];
bool x[12..14];
@end example

The first statement creates @code{x[0]}, @dots{}, @code{x[9]}; the
second creates @code{x[12]}, @dots{}, @code{x[14]}. This is a valid
sequence of statements, and it makes @code{x} a sparse array. The
following, on the other hand, is not valid.

@kindex Sparse array: overlap in range in instantiation
@example
bool x[10];
bool x[9..14];
@result{} @error{} Sparse array: overlap in range in instantiation
@result{} Original: [10]; adding: [9..14]
@end example

@noindent
Each index of an array can only be created once.

Arrays can be connected to others using the @code{=} operation. If two
arrays have the same size, the same type, and the same number of
dimensions, the connection is valid. Conceptually, connections are
performed by converting each array into an ordered list of individual
elements, where the order is specified by the lexicographic ordering
on their indices (the leftmost index has precedence). Finally, an
element-by-element connection is performed. This is illustrated
below.

@cindex array connections

@kindex Types `@var{type1}' and `@var{type2}' are not compatible
@example
bool x[10];
bool x[12..14];
bool y[2];
x=y;
@result{} @error{} Types `bool[ [10]+[12..14] ]' and `bool[2]' are not compatible
@end example

Note the syntax used to report the sparse array type as a combination
of two sub-arrays.

The dimensionality of the two arrays must match for a connection to
succeed, and their shapes also have to be compatible.

@kindex Type-checking failed in connection. incompatible number of dimensions

@example
bool x[12];
bool w[4][3];
x=w;
@result{} @error{} Type-checking failed in connection
@result{} Types `bool[12]' and `bool[4][3]' are not compatible
@end example

The following are examples of valid connections:

@example
bool x[10];
bool x[10..12];
bool y[13];
x=y; // @r{success!}

bool u[4][3];
bool v[4][3];
u=v; // @r{success!}
@end example

@cindex array, connections


@c ------------------------------------------------------------------------

@node Loops and Conditionals,  Scoping, Arrays, Introduction
@comment  node-name,  next,  previous,  up

@section Loops and Conditionals

@cindex loops
@cindex conditionals
@cindex if statement
@cindex selection statement
@cindex guarded command

Loops and conditionals can be used to describe complex circuit
structures in a compact manner. Loops are useful when creating array
structures, or connecting arrays in a regular manner. For example,
suppose @code{fulladder} is a process that contains channels @code{ci}
and @code{co} as its carry-in and carry-out. The following connects the
carry chain for a ten bit ripple-carry adder.

@example
fulladder fa[10];
(i : 9 : fa[i].co=fa[i+1].ci; )
@end example

The parentheses are used to group the body of the loop. @code{i} is
the dummy variable, and it ranges from zero to eight in this
example. The @code{;} is a separator, and separates each instance of
the body of the loop.  In general if only one integer is specified for
the range, the variable ranges from zero to one less than the integer.

The conditional statement uses the guarded command notation. They are
used for describing the edge of repetitive structures, during
recursive constructions, or for creating special versions of processes
based on parameters. The following is an example where odd-numbered
indices of @code{x} are connected to @code{y}, and even-numbered
indices are connected to @code{z}.

@example
bool x[10], y[10], z[10];

( i : 10 : 
   [ (i%2) = 0 -> x[i] = y[i];
   [] (i%2) = 1 -> x[i] = z[i];
   ]
)
@end example


@c ------------------------------------------------------------------------

@node     Scoping,  Intro to Namespaces, Loops and Conditionals, Introduction
@comment  node-name,  next,  previous,  up
@cindex scoping
@cindex variables, global
@section Scoping

In the second definition of @code{bitbucket}, the variable @code{p} was
defined within the body of the type definition. Therefore, this variable
is local to the type, and cannot be accessed by any construct outside
the body of the type. Different instances of @code{bitbucket} get
different copies of @code{p}, since it is a local variable. If we had
created a dualrail channel @code{p} after the bitbucket, this @code{p}
has no relation to the @code{p} in the body of @code{bitbucket}.

The @sc{act} language has two scopes: the global scope, and the scope
within the entity being defined. Ports of types have the same scope as
items defined within the body of the type. However, ports are special
in that they can also be accessed from outside the type using
dot-notation.

@cindex variables, shadowing

@sc{act} does not have a special ``global'' keyword. Global nodes can
be created by simply defining them in the outer-most scope. For
instance, @sc{act} files will tend to begin with
@example
bool Reset,Reset_;
@end example
@noindent
This permits the names @code{Reset} and @code{Reset_} to be used
throughout the @sc{act} file. 


@node   Intro to Namespaces,  Importing files, Scoping, Introduction
@comment  node-name,  next,  previous,  up

@section Namespaces

Complex projects involve a large number of @sc{act} files, including
shared libraries and blocks designed by different people. One could
easily envision a situation where a particular identifier name is used by
multiple designers to describe different processes.

To keep names of processes, channels, and types separate for different
parts of a design, @sc{act} provides the notion of a
@dfn{namespace}. Every instantiation and type definition resides in a
specific namespace. In all our examples so far, this was the
(implicit) global namespace (named @code{Global}).

The following example creates a namespace @code{lib} and defines types
within the namespace.

@example
namespace lib @{
  export defchan a1of2 <: chan(bool) (bool d0,d1,a) @{ @dots{} @}
@}

lib::a1of2 d;
@end example

We have created a channel definition of type @code{a1of2} within the
@code{lib} namespace. There are a few items that should be noted.
First, the directive @code{export} indicates that the @code{a1of2}
type is in fact visible outside the namespace scope. This is why we
can use the notation @code{lib::a1of2} to access this type. The
rationale for this is that one might have created a library, but might
only want a few types exposed (e.g. top-level cells). By default, a
type is not visible outside a namespace unless it is explicitly
@code{export}ed. Second, a user-defined namespace cannot contain any
global instances of processes. This means that the only legal items
within a namespace are namespace directives, type definitions, and
global data/channel types.

Namespaces can be nested. For instance, we could have:

@example
namespace processor @{

  namespace lib @{
       export defchan a1of2 = chan(bool) (bool d0,d1,a) @{ @dots{} @}
  @}

   lib::a1of2 d;
@}
@end example

In this example, @code{d} is instantiated from namespace @code{lib}
within namespace @code{processor}. This brings up another subtlety of
the @code{export} directive. An exported definition is only exported
one level up in the namespace hierarchy. Hence, although the channel
@code{processor::lib::a1of2} exists, it cannot be accessed outside the
@code{processor} namespace.

@kindex Type is not exported up the namespace hierarchy

@example
namespace processor @{

  namespace lib @{
       export defchan a1of2 = chan(bool) (bool d0,d1,a) @{ @dots{} @}
  @}

@}
processor::lib::a1of2 d;
@result{} @error{} Type is not exported up the namespace hierarchy:
@result{}    processor::lib::a1of2
@end example

If this channel needs to be visible
outside the @code{processor} namespace, this can be accomplished by
exporting the namespace itself.

@example
namespace processor @{

  export namespace lib @{
       export defchan a1of2 = chan(bool) (bool d0,d1,a) @{ @dots{} @}
  @}

@}
processor::lib::a1of2 d;
@end example

In this approach, every element that is exported from namespace
@code{lib} is also exported out of namespace @code{processor}.

Something that is a little unusual is that a type cannot be accessed
within a sub-namespace unless it is exported. For instance, in the
example above, if @code{a1of2} was defined within the
@code{processor}@ namespace, then it will not be visible within the
@code{processor::lib} namespace unless it is exported. An
@code{export} directive is needed to permit a type to be used in other
namespaces apart from the one in which the type was defined.

A namespace can have global variables. The global variables described
earlier were simply a special case corresponding to the namespace
@code{Global}. For instance, a collection of process definitions within
a namespace might have a reset signal that is global to the namespace
only, and which is generated using some logic defined within the
namespace. 

@c ------------------------------------------------------------------------

@node     Importing files,  Types, Intro to Namespaces, Introduction
@comment  node-name,  next,  previous,  up

@section Importing Files

The keyword @code{import} is used to include other design files. An
@sc{act} file can begin with a sequence of @code{import} statements.
If the same file is imported twice within the same scope, chances are
that some types would be multiply defined. To avoid such problems,
imports of files which have already been imported within the same
scope or an outer scope are ignored. Therefore, always use
@code{import} to include type definitions defined elsewhere.

@example
import "channel.act";
@dots{}
@end example

@noindent
@code{import} searches for the file in the current directory
first, then in the colon-separated path specified by @code{$ACT_PATH},
and finally in @code{$ACT_HOME/act}.

A typical project would contain multiple files, each possibly having
their own namespace. Namespaces can also have global variables, so
importing a namespace automatically creates an instance of the global
variables from that namespace, and from any sub-namespace that was also
imported. 

There are a few things that might create issues in such a situation.
First, duplicate namespaces might exist, especially when re-using old
files. For instance, suppose we have two files: @code{lib1.act}@ and
@code{lib2.act} both containing namespace @code{lib}, but having
definitions that are useful. Importing both would result in the union of
the namespaces, and could create naming conflicts (e.g. multiple
definition of types having the same name---an error). To solve this
problem, one can do the following:

@example
import "lib1.act";
open lib -> lib1;
import "lib2.act";
open lib -> lib2;
@end example

The @code{open} construct enables one to rename a namespace. Once this
has occured, there cannot be any naming conflicts. This version of
@code{open} is a renaming construct. The old name for the namespace is
eliminated.

A second issue is one that is more about convenience. Consider a
project that has many different people working on it, each in their
own namespace to avoid naming conflicts. This situation can result in
very long type names. Plus it would be more bookkeeping to have to
create a test environment for the types within, say,
@code{processor::lib}@---not just because of the long type names, but
because not all types might be exported! In this case we can say:

@example
import "lib.act";
open processor::lib;

a1of2 d;
@end example

This version of the @code{open} directive has two
functions: (i) it adds @code{processor::lib} to the search path for
types, and (ii) it allows one to access all types within the
namespace, not just the ones that are exported (including types within
nested namespaces). Note that this @code{open} statement will fail if
all types cannot be uniquely resolved.

The sequence of @code{open} and @code{import} statements can only be
at the beginning of an @sc{act} file.

A second version of import uses namespaces directly, but requires that
@sc{act} files be placed in locations that match the namespace
hierarchy. The import statement

@example
import processor::lib;
@end example

is equivalent to the following:

@example
import "processor/lib/_all_.act";
@end example

It assumes that the file @code{_all_.act} in the directory
@code{processor/lib} contains all the definitions corresponding to the
@code{processor::lib} namespace.

@c ------------------------------------------------------------------------
@c   Types
@c ------------------------------------------------------------------------

@node Types,  Basic types, Importing files, Top
@comment  node-name,  next,  previous,  up

@chapter Types and Variables

@cindex variables, lexical conventions
@cindex identifier, lexical conventions
@cindex type
@cindex cells
@cindex circuit element
@cindex definition
@cindex parameters
@cindex node

Variables are the basic data objects in @sc{act}. Instantiations specify
which variables are created, and state what type they have. The type of
an object completely specifies what the object is and how it can be
used.

Types come in two flavors: parameters and circuit elements. Parameters
are variables whose types are @code{pint}, @code{preal},
@code{pbool}, or arrays thereof. All other types refer to circuit
elements. The basic circuit element is a Boolean value
@code{bool}. Circuit element types are broken down into three
categories: processes (created with @code{defproc}), channels (created
with @code{defchan}), and data (created with @code{deftype}).

There are some restrictions on variable names. Ordinarily a variable
identifier can be constructed as an arbitrary sequence of underscores,
letters, and digits. Identifier names are case sensitive, so @code{case}
and @code{Case} are different identifiers.

@menu
* Basic types::         Basic types.
* Array types::         Creating arrays.
* User-defined types::  Creating new types.
* Parameterized types:: Creating types which are parameterized.
* Directionality::      Direction specifiers on data and channels.
* ptype type::          The ptype meta-parameter type.
* Subtyping::           Subtyping support and uses.
@end menu

@c ------------------------------------------------------------------------

@node Basic types,  Array types, Types, Types
@comment  node-name,  next,  previous,  up

@section Basic Types

@noindent
The following basic types are supposed by @sc{act}:

@itemize @bullet
@item Parameter types
@itemize @minus
@item @code{pint}, for unsigned integer parameters.
@item @code{pints}, for signed integer parameters.
@item @code{preal}, for real-valued parameters.
@item @code{pbool}, for Boolean-valued parameters.
@item @code{ptype}, for type parameters.
@end itemize
@item Data types
@itemize @minus
@item @code{bool}, for Boolean circuit signals.
@item @code{int}, for unsigned integer-valued data.
@item @code{enum}, for enumerations.
@item @code{chan}, for channels.
@end itemize
@end itemize
@cindex parameters
@cindex types, meta-language
@noindent
The first group of types (and arrays of them) are referred to
as @dfn{parameter} types or @dfn{meta-language} types. This is because
they do not represent physical entities in the circuit itself, but
rather values that are used to construct the circuit or specify circuit
parameters.

The @code{bool} type corresponds to an electrical node in the
circuit. Eventually all types get implemented using circuit elements and
@code{bool}s.

The @code{int}, @code{enum}, and @code{chan} types are used for
higher-level representations of the circuit. These types support
parameters, and are described in more detail later
(@pxref{User-defined types}).

Variables of these basic types can be created by specifying the type
name followed by a comma-separated list of identifier names.

@example
bool a,b,c,n1,n1x2;
pint x,y,z;
preal w2,w_3;
@end example

@cindex instantiation
@noindent
The statements above are referred to as @dfn{instantiations}, since they
create variables that are instances of the basic types. It is an error
to have more than one instantiation of a variable in the same scope.

@kindex Duplicate instance for name `@var{var}'

@example
bool a;
pint a;
@result{} @error{} Duplicate instance for name `a'
@end example

@cindex initializer
A parameter instantiation can be accompanied by a single @dfn{initializer}
(@pxref{Simple Connections}, which describes the equivalent for
non-parameter types) which initializes the value of a variable.
@example
pint a=5, c=8;
preal b=8.9;
@end example

@cindex initializer, order
The order of initialization of variables is left to right. 
Using constructs such as

@kindex The identifier `@var{var}' does not exist in the current scope

@example
pint a=c, c=5;
@result{} @error{} The identifier `c' does not exist in the current scope
@end example

@noindent
should be avoided, as this leads to the error shown above indicating
that @sc{act} does not know about variable @code{c} in the
initialization of @code{a}. Constructs where the two instances
and initializers are listed in an order that does not lead to an error
are deprecated even they are well-defined.

@c ------------------------------------------------------------------------

@node Array types,  User-defined types, Basic types, Types
@comment  node-name,  next,  previous,  up

@section Array types

@cindex array
@cindex array range
@cindex range
@cindex array, multidimensional
@cindex array, sparse

An array of a basic type or user-defined type can be created using
@sc{act}'s array syntax. The syntax is based on C-style arrays, and
examples of creating arrays are shown below:

@example
int ar1[4]
preal ar2[7]
bool ar3[1..6]
@end example

@noindent
The number in square brackets specifies the range of the array. In the
first two examples, valid array indices range from zero to three and
zero to six respectively. The third example specifies the array indices
to range from one to six. In general, if the array index range is
specified by a single integer, the lower bound of the range is zero, and
the upper bound is the specified integer minus one. Instead of simple
integers, arbitrary integer expressions can also be used as array range
specifications, as shown below.

@example
int ar4[5*3]
preal ar5[7*x+(y%2)-p] // @r{here @t{x}, @t{y}, and @t{p} must be integer parameter types}
@end example

Expressions used to specify array ranges must be of integer
type. Variables used must always be parameter types (typically @code{pint}).

@kindex Expression must be of type int

@example
preal a = 4.3;
bool ar6[7*a+5];
@result{} @error{} Expression must be of type int
@end example

Multidimensional arrays are specified by additional square brackets. Two
and three-dimensional arrays of @code{bool}s are specified as shown in
the example below.

@example
bool x[5,3];
bool y[1..6][9][2..10];
@end example

@sc{act} provides a mechanism for constructing @dfn{sparse arrays},
i.e., those whose range need not be a single contiguous block. It is
possible to create an array of nodes whose elements exist only at, say,
positions 4 and 6 of the array. The syntax for creating the
aforementioned array is shown below.

@example
bool n[4..4], n[6..6];
@end example

@noindent
These sparse array instantiations can be mixed with ordinary
instantiations, permitting the definition of arrays which can be
dynamically extended in @sc{act}.

@example
bool n[5];
bool n[10..12]; // @r{@code{n} is now defined at positions 0--4, 10--12}
@end example

@noindent
The definition below specifies an instantiation of elements of array
@code{m} at positions @code{[6][5]}, @code{[6][6]}, @dots{},
@code{[6][10]}.

@example
bool m[6..6][5..10]
@end example

@noindent
Note that this is quite different from the statement

@example
bool m[6][5..10];
@end example

@noindent
which indicates that array @code{m} is to be instantiated at positions 
@code{[0][5]}, @dots{}, @code{[5][10]}.

Unlike ordinary instances, array instantiations cannot be followed by
initializers (@pxref{Array Connections}).

@kindex Connection can only be specified for non-array instances
@example
bool x[10];
bool y[10] = x;
@result{} @error{} Connection can only be specified for non-array instances
@end example

For type-checking purposes, an array is defined by its base type
(@code{bool} in the example above), number of dimensions, and the
shape of the array in each dimension.


@c ------------------------------------------------------------------------

@node User-defined types,  Parameterized types, Array types, Types
@comment  node-name,  next,  previous,  up

@section User-defined types

@cindex type, body
@cindex type, definition
@cindex type, declarations
@cindex type, user-defined
@cindex type, creating

User-defined type can be used to create complex circuit structures.  A
new user-defined type name is introduced by using @code{defproc},
@code{defcell}, @code{defchan}, or @code{deftype}
statements. All user-defined types have the same basic structure: (i)
a type signature, that provides information about the interface to the
type and the ports that are externally visible; and (ii) a @dfn{body},
contained in braces, that specifies the detailed definition of the
user-defined type. The type chosen for each port must be the most
specific type used by that port in the body (@pxref{User-defined Connections}).

User-defined types can also be parameterized, and this is covered in
detail later (@pxref{Parameterized types}).

@subsection Processes and Cells

@cindex process
A process is a user-defined type that corresponds to a circuit
entity. Other hardware description languages sometimes call it a module
or a subcircuit. The basic syntax of a process definition is shown below.

@cindex defproc
@example
defproc test (bool n, m; bool p, q)
@{
@dots{}
@}
@end example

@noindent
The definition above creates a new process, called @code{test}, that has
a port list consisting of four @code{bool}s. This port list cannot
contain any parameter types (@code{pint}, etc).

If the body of the user-defined type is replaced by a single
semi-colon or is empty, the statement corresponds to a type
@dfn{declaration}. Declarations are typically used when defining
mutually recursive types. The declaration corresponding to type
@code{test} is:

@example
defproc test (bool n, m; bool p, q);
@end example

If the process is never defined, @sc{act} assumes that it has an empty
body. If a process declaration is followed by a definition, the type
signature must match exactly.

@kindex Name `@var{type}' previously defined as a different process

@example
defproc test (bool n, m; bool p, q);
defproc test (bool n, m; bool p) @{ @}
@result{} @error{} Name `test' previously defined as a different process

@end example

@noindent
A type can only have one definition in a given scope.

@kindex Process `@var{type}': duplicate definition with the same type signature

@example
defproc test (bool n) @{ @dots{} @}
defproc test (bool n) @{ @dots{} @}
@result{} @error{} Process `test': duplicate definition with the same
@result{} type signature
@end example

@cindex scope, type names
@cindex scope, variable names
@cindex namespaces

The body of a process specifies its implementation. This can use a
combination of instances of other processes, connections, and other
languages like production rules. Loops and conditional statements can
also be used to construct a process.

@cindex ports

Port lists have a syntax similar to instantiations. A type
specifier can be followed by a list of identifiers rather than just a
single identifier, similar to an instantiation. Semicolons are used
to separate parameters of differing types, as shown in the example
below.

@example
defproc test2(bool n,m; d1of2 p,q) @{ @dots{} @}
@end example

In this example we assumed that there was a user-defined type (or
channel) called @code{d1of2} that was used in the port list. Any
user-defined type in the port list must be either a data or channel
type. Processes are supposed to correspond to circuit blocks, and so
cannot be port parameters to other circuit blocks.

@cindex array, within parameter lists

@noindent
Square brackets can also be used following the identifier names to
specify array ports. The
meaning of these square brackets is identical to the ordinary
array instantiation (@pxref{Array types}). However, the arrays in port
lists are restricted to be dense arrays indexed at zero. This
restriction is enforced by syntax, and will be reported as a parse
error.

@kindex Expecting token `@code{]}', got `@code{.}'
@example
defproc test1 (bool a,b,c, d[10]) @{ @}  // @r{success!}
defproc test2 (bool a,b,c, d[0..9]) @{ @}
@result{} @error{} Expecting token `]', got `.'
@end example

The ports themselves cannot be converted to sparse arrays within the
body of a definition. This means that the following is illegal:

@kindex Array instance for `@var{var}': cannot extend a port array
@example
defproc test1 (bool a, b, c, d[10])
@{
  bool d[11..12];
  @dots{}
@}
@result{} @error{} Array instance for `d': cannot extend a port array
@end example

Type names and variable names do not share the same name space.
Creating a type definition with the same name as an instance variable or
vice versa is allowed, but deprecated.

@cindex cell
Cells follow the same rules for definition as processes, except the
keyword @code{defcell} is used in place of @code{defproc}. The reason
for separating cells from processes is that processes are supposed to
correspond to logical entities that are meaningful semantic
objects. For example, a process ordinarily has its origins in a CHP
language description (@pxref{Languages}). Cells, on the other hand,
can be fragments of logical processes. Examples of cells are standard
gates like C-elements, NAND, or NOR gates, or commonly used circuit
structures like completion detection logic. Cells are distinguished
from processes to make it easier to write automation tools.

@subsection Data types

A data type is defined using @code{deftype}. A data type corresponds
to an integer or Boolean value, although it could also be a composite
construct like a record or structure (from software programming
languages). The syntax is similar to a process, and the constraints
about declarations/etc. apply here as well.

Data types have some additional structure that is not required for a
process. In particular, the body of the data type and its type
signature provide information that relates a user-defined data type to
a previously defined or built-in data type. When a user-defined data
type is specified, a method for setting the value of the data type and
reading its value must also be specified. If omitted, certain features
of data types will not be enabled for the defined type.

The following is a simple example of a datatype that creates a dual-rail
representation for a Boolean variable. The first line specifies that
@code{d1of2} is a new data type, and it implements the built-in type
@code{int<1>}---a one-bit integer (@pxref{Parameterized types}).

@cindex deftype
@example
deftype d1of2 <: int<1> (bool d0,d1)
@{
  spec @{
    exclhi(d0,d1)
  @}
@}
@end example

The body of the type is similar to a process, except it can only contain
connections, @code{spec} bodies, and special @dfn{methods}. The
following would result in an error:

@kindex Expecting bnf-item `@code{methods_body}', got `@code{bool}'

@example
deftype d1of2 <: int<1> (bool d0,d1)
@{
  bool p;
  spec @{
    exclhi(d0,d1)
  @}
@}
@result{} @error{} Expecting bnf-item `methods_body', got `bool'
@end example

There are two methods that can be specified for a data type: (i) a @dfn{set
method}, used to write a value to the type; (ii) a @dfn{get method},
used to read the value of the type. One can think of these as type
conversion methods invoked automatically to read or write the data
type.

@cindex set method
@cindex get method
@cindex method, set
@cindex method, get

@example
deftype d1of2 <: int<1> (bool d0,d1)
@{
   spec @{
    exclhi(d0,d1)
   @}
   methods @{
     set @{
       [self=1->d1-;d0+ [] self=0->d0-;d1+]
     @}
     get @{
       [d0->self:=1 [] d1->self:=0]
     @}
   @}
@}
@end example

In the example above, the @code{set} method says that the way to set a
@code{d1of2} data type to the value @code{0} is to set @code{d0} to
@code{false} and @code{d1} to @code{true}. The special variable
@code{self} is used to specify the @code{int<1>} value of the type, and
the methods specify conversion operations.

The selection statement in the @code{get} method uses the
deterministic selection operator @code{[]} (@pxref{Languages}). This
is an implicit check that when the @code{get} method is invoked,
signals @code{d0} and @code{d1} cannot both be @code{true}. We have
also made this explicit in the specification body. Also, if both
@code{d0} and @code{d1}@ are false (i.e. an illegal state in which to
execute a get operation), the variable @code{self} is not assigned;
the operation waits for at least one of @code{d0} or @code{d1} to be
true. This is viewed as an error for a data type. (This is different
in the case of a channel, where the semantics of the channel permit
waiting.)

Port lists for data types can be either built-in data types or
user-defined data types. Channels (built-in or user-defined) and
processes are not valid types for ports of a data type, since a data
type is supposed to represent a circuit structure that is used to
represent a data value.

@subsection Channels

Channels are similar to data types. Instead of relating a user-defined
channel to built-in data, we relate them to a built-in channel types
instead. The methods required for supporting the full functionality of
a channel are operations necessary to send and receive data on the
channel, rather than a read and write operation on a data value.

There are six possible methods that can be defined for a channel type:

@itemize @bullet
@item Methods for sending and receiving values on the channel
@itemize @minus
@item @code{set}, @code{send_rest}: together these two operations
implement a send operation on the channel. The send operation consists
of two parts: (i) setting the data value to be sent (@code{set}); and
(ii) completing the synchronization operation (@code{send_rest}).
@item @code{get}, @code{recv_rest}: together these two operations
implement a receive operation on the channel. The receive operation
consists of two parts: (i) getting the value that has been transmitted
along the channel (@code{get}); and (ii) completing the
synchronization operation.
@end itemize
@item Methods for probing a channel to determine if there is
synchronization operation being attempted.
@itemize @minus
@item @code{send_probe}: this is the probe operation for the sending
end of the channel. It corresponds to the receiver being ready to communicate.
@item @code{recv_probe}: this is the probe operation for the receiving
end of the channel. It corresponds to the sending being ready to communicate.
@end itemize
@end itemize

The send operation @code{X!e}@ in the CHP language corresponds to two
parts: setting the data value, followed by the synchronization
operation. Setting the data value also indicates that the sender is
ready to communicate. It is illegal to set the data value multiple
times without an intervening synchronization operation. Finally,
attempting to set the data value might block if the previous channel
operation has not completed as yet. Whether or not this could occur
depends on the channel protocol.

The receive operation @code{X?v}@ in the CHP language corresponds to
two parts: receiving the data value, followed by the synchronization
operation. Attempting to get the data value from the channel will
block if the sender has not provided any value. Once a value has been
extracted from the channel, the synchronization operation can be
executed. Prior to the synchronization, multiple get operations can be
executed; the channel must be designed so that subsequent get
operations will return the same value as the first one, and will be
guaranteed not to block. The get operation is used to implement a CHP
value probe, where the receiver can peek at the value pending in the
channel without attempting a synchronization operation.

An example definition of a Boolean channel where the channel has an
lazy-active send and passive receive is below.

@example
defchan e1of2 <: chan(bool) (bool d0,d1,e)
@{
   spec @{
    exclhi(d0,d1)
   @}
   methods @{
    set @{
      [e];[self->d1+[]~self->d0+]
    @}
    send_rest @{
      [~e];d0-,d1-
    @}
    get @{
     [d0->self-[]d1->self+]
    @}
    recv_rest @{
     e-;[~d0&~d1];e+
    @}
    recv_probe = (d0|d1);
   @}
@}
@end example

@cindex send_rest method
@cindex recv_rest method
@cindex method, send_rest
@cindex method, recv_rest

In the example above, the @code{set} and @code{send_rest} methods
specify the sequence of operations on the channel variables that are
invoked for a send action. The @code{get} and @code{recv_rest} methods
specify the sequence of operations used to perform a receive. The
special variable @code{self} is used to specify the @code{bool} value
that is being either sent or received on the channel.

This channel has an active send and passive receive, and hence probes
are only supported at the receiver. The @code{recv_probe} method
expression specifies the Boolean expression corresponding to the probe
at the receiver end of the channel. A @code{send_probe} can be
specified in a similar way when the sender is passive and receiver is
active.

The @code{e1of2} channel has been specified to perform a four-phase
handshake protocol. If the channel were to correspond to a two-phase
protocol, a different sequence of actions can be specified instead.

Port lists for channel types can be data types (built-in or
user-defined) or channels. Processes are not valid types for ports of a
channel type.


@c --------------------------------

@subsection Instantiating User Types

User-defined type variables can be instantiated in much the same manner
as ordinary type variables.

@example
defproc test(bool N, n) @{ @dots{} @}
test x;
// @code{x.N} @r{and} @code{x.n} @r{refer to the ports of} @code{x}
@end example

@cindex dot notation
@cindex type, fields of
@cindex type, parameters

@noindent
creates an instance of type @code{test} named @code{x}. Creating an
instance of a type creates instances of all the ports listed as
well as creating whatever is specified by the body of the type
definition. The list of ports of a user-defined type can be
accessed from the scope outside the type definition by using
dot-notation. These externally visible ports are analogous to the
@dfn{fields} of structures or record types in standard programming
languages.

This analogy to records can be used to build complex data types,
albeit with slightly different syntax compared to traditional
programming languages. The following is a simple example that
illustrates this. 

@example
deftype mystruct <: int<16> (int<4> f1, f2; int<8> f3)
@{
  methods @{
   set @{
     f1:=self >> 12;
     f2:=(self >> 8) & 0xf;
     f3:=self & 0xff
   @}
   get @{
     self:=(f1 << 12) | (f2 << 8) | f3
   @}
  @}
@}
@end example


@c ------------------------------------------------------------------------

@node Parameterized types,  Directionality, User-defined types, Types
@comment  node-name,  next,  previous,  up

@section Parameterized types

Parameterized types give @sc{act} considerable flexibility in type
definitions. Parameterized types come in two flavors: built-in types,
and user-defined types. For user-defined types, @sc{act} guarantees
that the order in which parameters are created and initialized is from
left to right. Therefore, one can use the value of one parameter in
the definition of another one.

@subsection Built-in Integers and Channels

Although we have been describing the types @code{int} and @code{chan}
as simple types, they are in fact paramterized. Omitting the
parameters makes @sc{act} use implicit default parameters for both of
them.

The @code{int} type is parameterized by the number of bits used to
specify the integer. This bit-width can be specified using angle
brackets, as shown below:

@example
int<1> x; // x @r{is a one bit integer}
int<37> y; // y @r{is a thirty-seven bit integer}
@end example

@cindex integers

When interpreting these bits as integers, @sc{act} assumes an unsigned
binary representation. The default bit-width is thirty-two.

The channel type @code{chan} can be parameterized by the type that is
being sent and received on the channel.

@example
chan(bool) x; // x @r{is a Boolean channel}
chan(int<16>) y; // @r{is a 16-bit integer channel}
@end example 

The default data type for a channel is assumed to be the default
@code{int}, namely @code{int<32>}.

Another built-in data type is the @emph{enumeration} type. An
enumeration type corresponds to integer-valued variables with a
restricted range.

@example
enum<5> x; // x @r{can take on values 0, 1, 2, 3, 4}
@end example

For convenience, these values are treated as integers for the purposes
of expressions. Also, enumerations that have power-of-two ranges are
type-equivalent to the approprate @code{int} type. For instance,
@code{enum<2>}@ is equivalent to @code{int<1>}. Enumerations are
useful when specifying a data value that is a one-hot code.

@subsection User-defined Types

Processes, channels, and datatypes created using @code{defproc},
@code{defchan}, and @code{deftype} all support
parameterization. Parameters are specified using the @code{template}
keyword.

@cindex templates
@cindex types, parameterized

Since the syntax for all three is the same, we use a process
definition to illustrate this. To create a parameterized type, the
definition of the type is preceeded by a template specifier as shown
below.

@example
// A generic adder block
template<pint N> 
defproc adder (e1of2 a[N], b[N]; e1of2 s[N])
@{
  @dots{}
@}
@end example

This example defines an @code{adder} that takes @code{N} as a
parameter. Note that the value of @code{N} determines the size of the
arrays in the port list for the process. Instances of this
@code{adder} can be created in the following way:

@example
adder<4> a1;  // a1 @r{is a 4-bit adder}
adder<16> a2; // a2 @r{is a 16-bit adder}
@end example

The value of @code{a1.N} is 4, while the value of @code{a2.N} is
16. To illustrate how one might define this adder block, assume we
have processes @code{fulladder}, @code{zerosource}, and
@code{bitbucket} already defined that implement a full-adder, a
constant source of zeros, and a constant sink respectively. One
possible definition of the adder would be:

@example
template<pint N>
defproc adder (e1of2 a[N], b[N]; e1of2 s[N])
@{
   fulladder fa[N];
   ( i : N-1 : fa[i].a = a[i]; fa[i].b = b[i]; fa[i].s = s[i];
                fa[i].co = fa[i+1].ci; )
   zerosource z;
   bitbucket w;
   fa[0].ci=z.x;
   fa[N-1].co = w.x;
@}
@end example

This creates a parameterized ripple-carry adder. Notice the use of
loops and arrays to connect the carry chain for the adder, and the
inputs and outputs of the process to the @code{fulladder} ports.

As shown in the example above, the arguments in the template parameter
list are specified by listing them next to the type name
(@pxref{User-defined Connections}). Trailing arguments can be omitted
from the parameter list attached to the type as shown in the example
below.

@example
template<pint N; preal w[N]>
defproc test (bool n[N]) @{ @dots{} @}

test<5> x;
@end example

Channels and data types can also be parameterized in the same way. For
example, the following might be an N-bit dual rail definition.

@example
template<pint N>
deftype d1of2 <: int<N> (bool d0[N], d1[N]) @{ @dots{} @}
@end example

Since the body of the type can use loops and selection statements in
arbitrary ways, changing the parameters for the type can completely
change the structure of the circuit. It can also change the ports for
the type. Hence, when checking for type compatibility, the values of
parameters are also taken into account. Hence, the full type for
instance @code{a2} above is in fact @code{adder<5>}, not just
@code{adder}. Types such as @code{fulladder} that do not have
parameters are more completely specified as @code{fulladder<>},
although the angle brackets can be omitted. Arrays can only correspond
to instances of the same type---so an array cannot contain a three-bit
adder and five-bit adder.

@node Directionality, Subtyping, Parameterized types, Types
@comment  node-name,  next,  previous,  up

@section Directional Types

Data and channel types also support access permissions in terms of valid
operations on the types. To illustrate this, consider the simplest data
type, namely a @code{bool}. There are three different ways a @code{bool}
type can be defined, and they are shown below:

@cindex types, !
@cindex types, ?

@example
bool x;  // @r{Boolean that may be read or written}
bool! y; // @r{Boolean that must be written, and may be read}
bool? z; // @r{Boolean that must be read, and cannot be written}
@end example

The @code{!} and @code{?} suffixes constrain the way in which the type
can be accessed. The primary use of this is in port lists, where one can
specify what variables are read and written by a process. The same
syntax can be used (with the same meaning) for user-defined data types.

The following example shows a possible definition for a two-input nand
gate that takes two inputs @code{a} and @code{b}, and produces its
output on @code{c}.

@example
defproc nand2 (bool? a, b; bool! c) @{ @dots{} @}
@end example

Channels support a similar syntax, but the meaning is slightly
different.

@example
chan(int) x;  // @r{Sends or receives are allowed}
chan!(int) y; // @r{Only sends permitted}
chan?(int) z; // @r{Only receives permitted}
@end example

Again, the same syntax is valid for user-defined channels. These
constructs are useful in libraries for additional error checking, and
conveying more information to the user of the library.

@subsection Interaction with user-defined types

Direction specifications can be used for built-in data and channel
types, as well as user-defined types. Consider the @code{e1of2}
user-defined channel type that we saw earlier:

@example
defchan e1of2 <: chan(bool) (bool d0,d1,e)
@{
   spec @{
    exclhi(d0,d1)
   @}
   methods @{
    set @{
      [e];[self->d1+[]~self->d0+]
    @}
    send_rest @{
      [~e];d0-,d1-
    @}
    get @{
     [d0->self-[]d1->self+]
    @}
    recv_rest @{
     e-;[~d0&~d1];e+
    @}
    recv_probe = (d0|d1);
   @}
@}
@end example

When we use @code{e1of2?} or @code{e1of2!}, we need some mechanism to
specify the access permissions for the @emph{port parameters} of the
user-defined type. The convention used is that there are five possible
ways to specify any constraints on access to port parameters. For our
example, we can use one of the following variations:
@example
bool d0; // @r{No constraints; this port could be read or written}
bool! d0; // @r{Both @code{e1of2?} and @code{e1of2!} have @code{bool!} permissions}
bool? d0; // @r{Both @code{e1of2?} and @code{e1of2!} have @code{bool?} permissions}
bool?! d0; // @r{@code{e1of2?} has @code{bool?} permissions, and @code{e1of2!} has @code{bool!} permissions}
bool!? d0; // @r{@code{e1of2?} has @code{bool!} permissions, and @code{e1of2!} has @code{bool?} permissions}
@end example

@cindex types, !?
@cindex types, ?!

Hence, a better definition of an @code{e1of2} channel would more
completely specify the access permissions for the port parameters in
the following way.

@example
defchan e1of2 <: chan(bool) (bool?! d0,d1; bool!? e) @{ @dots{} @}
@end example

A careful examination of the type signature reveals that the sender
and receiver have the appropriate permissions. There is a subtle
interaction between connections and directional
types in @sc{act}. This is detailed in @pxref{User-defined Connections}.

@node  Subtyping,  ptype type, Directionality, Types
@comment  node-name,  next,  previous,  up

@section Implementation and refinement


When types are created using either @code{deftype} or @code{defchan},
they are defined as the implementation of a type. This is also
possible for processes defined using @code{defproc}.

@subsection Implementation

The implementation relation is used to specify the precise
implementation of a data or channel type. The most straightforward
mechanism to specify a channel is to say that it is the implementation
of a built-in data type. In the example above, the channel
@code{e1of2} is defined to be an implementation of a
@code{chan(bool)}. The implementation has additional port parameters,
and it specifies the communication protocols for a send and receive
action. The syntax that is used to say that we have an implementation
is the @code{<:} symbol between the name of the type and the parent type
that it is related to.

When a type implements another one, the new type can be used in places
the old type was used. While this is superficially similar to
subtyping in programming languages, it is better viewed as a
refinement relationship. So, if type @code{tA} implements type
@code{tB}, then @code{tA} has a more detailed description of the
implementation compared to @code{tB}. Type @code{tB} is the
@dfn{parent type} for type @code{tA}. As seen earlier, each data type
or channel type can have a method body that specifies all the
operations that can be performed using the type. These method bodies
relate operations on the type to operations on the parent type
(through @code{self}).


Different implementations of the same type are not equivalent or
interchangeable. For example, one can imagine two different
implementations of an @code{int<2>}: two dual-rail codes, or a
one-of-four code. Both are implementations, but they are not
equivalent to each other.


A more interesting option is to use refinement between two
user-defined types. Refinement is used to create related versions of
an existing type. If type @code{foo} implements @code{bar}, then the
basic rule is that one can use @code{foo} instances in all the same
contexts where @code{bar} instances can be used. The meaning of
defining one type to be an implementation of another is discussed in
detail below.


@subsection Refinement

When a user defined type implements another, there are several items
to consider: (i) the template parameters (if any); (ii) the port
parameters; and the body of the new type. Since the new type is
supposed to implement the old one, @sc{act} defines the template
parameters and port parameters for the new type using the old type as
a starting point.

The port list of the new type consists of the original port list in
the base type plus the additional ports specified in the type
definition---in other words, the new type @emph{extends} the original
port list. As an illustration, consider:

@example
defproc type1 (bool a, b) @{ @dots{} @}
defproc type2 <: type1 (bool c) @{ @dots{} @}
@end example

In this case @code{type2} would have ports @code{a}, @code{b}, and
@code{c}, since it is an implementation of @code{type1}.

Template parameters are handled in a similar fashion, except there is
a complication. In the example below, @code{type2} would have two
template parameters @code{N} and @code{M}, as might be expected from
the port list example above.

@example
template<pint N>
defproc type1 (bool a, b) @{ @dots{} @}

template<pint M>
defproc type2 <: type1 (bool c) @{ @dots{} @}
@end example

However, we can also define @code{type2} in the following manner:

@example
template<pint N>
defproc type1 (bool a, b) @{ @dots{} @}

template<pint M>
defproc type2 <: type1<4> (bool c) @{ @dots{} @}
@end example

In this version, the template paramter from @code{type1} has been
specified in the type definition for @code{type2}. To permit this
feature, template parameters for the new type are defined in the
following manner:
@itemize @bullet
@item Template parameters are categorized as @dfn{definable parameters} versus
@dfn{pre-specified parameters}. Fresh template parameters are always
definable.
@item Pre-specified parameters are not part of the parameter set that
can be specified when a type is created.
@item The value of the pre-specified parameter is computed based on
the type signature.
@item The list of parameters accessible in the body of the type and
outside the type is the combination of the ones defined by the new
type and the parent type.
@item The order of template parameters in the new type corresponds to
the new parameters first (in the order specified), followed by any
definable parameters left in the parent type.
@end itemize

So in the example above, we could create an instance of @code{type2}
as follows:

@example
type2<5> x;
// x.N, x.M @r{are both accessible!}
@end example

The parameter @code{N} for @code{x} will be @code{4}, since that has
been pre-specified in the type definition for @code{type2}. If instead
we had specified @code{type2 <: type1} as in the earlier example, then
the instance

@example
type2<5,7> x;
// x.M=5, x.N=7
@end example

would set @code{N} (the new template parameter) to @code{5}, and
@code{M} (the parent, still definable parameter) to @code{7}. Finally,
the following would be an error:

@kindex Duplicate meta-parameter name in port list: `@var{N}'
@kindex Conflict occurs due to parent type: @var{type}

@example
template<pint N> defproc type1 (bool a, b) @{ @dots{} @}
template<pint N> defproc type2 <: type1 (bool c) @{ @dots{} @}
@result{} @error{} Duplicate meta-parameter name in port list: `N'
@result{} Conflict occurs due to parent type: type1
@end example
since the name of the template parameter is repeated.



The body of the new type is the union of the original type definition
and the new body. As an example to illustrate how this might be used,
consider the following example: 

@example
defproc buffer (e1of2? l, e1of2! r)
@{
   bool x;

   chp @{
     *[ l?x;r!x ]
   @}
@}
@end example

@code{buffer} specifies the CHP description for a one-place FIFO. This
can be implemented using a variety of circuits, and hence we could
define a specific implementation as follows:

@example
defproc wchb <: buffer ()
@{
   prs @{
     @dots{}
   @}
@}
@end example

The process @code{wchb} is a specific implementation of the buffer
(without any extra ports) that contains a particular production-rule
implementation of the same buffer.

@subsection Overrides

Consider the buffer example above. A better and more abstract
specification for a buffer at the CHP level of abstraction would be:

@example
defproc buffer (chan?(bool) l, chan!(bool) r)
@{
   bool x;

   chp @{
     *[ l?x;r!x ]
   @}
@}
@end example

The production rules for this buffer use the fact that the Boolean
channel for @code{l} and @code{r} is in fact an @code{e1of2}
channel. Because an @code{e1of2} channel implements a
@code{chan(bool)}, @sc{act} provides a mechanism to say that an
implementation of a process also replaces existing types with new
implementations of the same type. This mechanism is called an
@dfn{override}, because old types can be @emph{overridden} with new
ones that implement them.

Variables in the port list as well as the body of a type can be
overridden. For this to be sound, the new type must be an
implementation of the original. The syntax for this is shown below:

@example
defproc wchb <: buffer
+@{ e1of2 l, r; @} // override block
@{
   prs @{
     @dots{}
   @}
@}
@end example

In this version, the original process implements a buffer with
channels, and the @code{wchb} specifies that the channel is a
@code{e1of2}.  The first abstract buffer can be used with different
handshake protocols on channels, or with different circuits.

The ``@code{+@{ @dots{} @}}'' indicates the override block. The override
block uses the instantiation syntax to specify override types. The
only syntax permited is of the form within an override block is

@example
+@{
    @var{type} @var{list-of-ids};
    @dots{}
 @}
@end example

The identifiers cannot contain array specifiers, and the types canot
have any direction flags. The identifier names must match names in the
parent type (either in the port list or in the body of the type). If
the original identifier was declared as an array, the entire array
will be overridden. Direction flags from the parent type will be
inherited by the overridden type.

Implemetation relations introduced should be handled with care. For
example, suppose one has two definitions of a buffer: one using the
CHP language, and the other using the PRS language (as above), and
consider the variable @code{x}. Now this internal variable which is in
the CHP language may not be part of the PRS for the WCHB
reshuffling. In other words, the @code{wchb} process will not have any
internal variable that corresponds to @code{x} in the CHP language!
Similarly, the @code{wchb} PRS language will contain additional
variables that are not present in the CHP language. The relation
between such variables is unspecified by the implementation
relationship.

@b{XXX: test this}

An additional complication arises if the process @code{wchb} ends up
introducing a state variable @code{x} in the PRS language that does
correspond to the @code{bool x} in the CHP language. In this case, one
should override @code{x} as well with the appropriate detailed
representation of the Boolean variable.


@node ptype type,  Expressions, Subtyping, Types
@comment  node-name,  next,  previous,  up

@section The ptype type

@b{XXX: this section not yet implemented}

The special @code{ptype} meta-parameter type is used to pass in types
into a process definition. These types can be used to build a process
using other processes as building blocks. The syntax for using a
@code{ptype} is the following:

@example
ptype(foo) x;
@end example

This says that @code{x} is a variable that is a type, with the
constraint that @code{x} must satisfy the type signature specified by
@code{foo}. In other words, @code{x} is guaranteed to support all the
operations supported by type @code{foo}. 

@code{ptype} parameters can also be used in templates. Consider the
following example:

@example
// A constructor for a datapath with W-bit ripple connections, and
// where each component has M inputs and one output

// A skeleton
template<pint W, pint M>
defproc bitslice (e1of2? rin[W]; e1of2! rout[W]; 
                  e1of2? in[M]; e1of2! out) @{ @}

// the constructor
template<pint N, pint M, pint W, ptype(bitslice<W,M>) t>
defproc build_dpath (e1of2? rin[W]; e1of2! rout[W]; 
                     e1of2? in[M*N]; e1of2! out[N])
@{
   t x[N];

   // ripple connections
   (;i:N-1: x[i].rout=x[i+1].rin);
   x[0].rin=rin;
   x[N-1].rout=rout;   

   // i/o connections
   (;i:N: x[i].in[i*M..(i+1)*M-1] = in[i*M..(i+1)*M-1];
          x[i].out=out[i] )
@}

// A one-bit adder
defproc onebit (e1of2? in[2], rin[1]; e1of2! out, rout[1]) @{ @dots{} @}

defproc ripple_adder (e1of2? a[32], b[32], cin; e1of2! out[32], cout)
@{
    build_dpath<32,2,1,onebit> dp;

    (; i : 32 : dp.in[2*i] = a[i]; dp.in[2*i+1] = b[i]);
    dp.out = out;
    dp.rin[0] = cin;
    dp.rout[0] = cout
@}
@end example




@c ------------------------------------------------------------------------
@c   Expression syntax
@c ------------------------------------------------------------------------
@node Expressions, Connections, ptype type, Top
@comment  node-name,  next,  previous,  up

@chapter Expressions

@cindex expressions

Expression syntax in @sc{act} is similar to expressions in the C
language. Operators that are supported include @code{+}, @code{-},
@code{*}, @code{/}, and @code{%} for integer arithmetic operations,
and @code{&}, @code{|}, and @code{~} for bit-wise logical operations
between integers.

Boolean expressions can be constructed from Boolean variables, the
constants @code{true} and @code{false}, and the Boolean operators
@code{&}, @code{|}, and @code{~} denoting the and, or, and negation
operations respectively. (This is a departure from C, where and/or
operations between conditions use @code{&&} and @code{||}.)

Numeric expressions can be compared using
@code{<}, @code{<=}, @code{>}, @code{>=}, @code{=}, and @code{!=} for
the operators less than, less than or equal to, greater than, greater
than or equal to, equal to, and not equal to respectively.

Finally, there are the logical shift operators @code{<<} and
@code{>>}, along with the arithmetic right shift operator @code{>>>}.

Expressions can also include function calls, with the usual function
call syntax.

Typing rules for integers (what happens when you mix int, pint).

Signed and unsigned, and what happens if you mix them.

Type coersions (enum, int, bool).


@c ------------------------------------------------------------------------
@c   Connections
@c ------------------------------------------------------------------------

@node  Connections,  Simple Connections, Expressions,  Top
@comment  node-name,  next,  previous,  up

@chapter Connections

@cindex connection

When two nodes are connected to each other by wires, they effectively
become one electrical node. This connection operation is part of the
@sc{Act} language, and is denoted by the @code{=} sign.  The @code{=}
operation is also overloaded for meta-language variables to denote
assignment. Multiple connections can be specified in a single statement
by repeatedly using the @code{=} operator. This section describes the
different connection statements supported by @sc{Act}.


@menu
* Simple Connections:: 		Simple connections.
* Array Connections::		Connecting arrays.
* User-defined Connections::	Connecting user-defined types.

@end menu

@c ------------------------------------------------------------------------

@node Simple Connections,  Array Connections, Connections, Connections
@comment  node-name,  next,  previous,  up

@section Simple Connections

@cindex connection, simple
@cindex connection, meta-language
@cindex assignment
@cindex connection, node

The simplest possible connection statement is the connection of two
variables of type @code{bool}.

@example
bool x, y;
x=y;
@end example

@noindent
The effect of this operation is to alias the two nodes. After this
operation is performed, both @code{x} and @code{y} refer to the same
value.  Meta-language types can also be ``connected'' to expressions.
The result of such a ``connection'' is that the right hand side of the
@code{=} sign is evaluated, and assigned to the variable on the
left. Such connections are only meant to initialize the values of
parameters.

@example
pint x, y;
x=5;
y=x*1+2;         // @r{success}
@end example

@noindent
Whereas connecting nodes is a symmetric operation, connecting
meta-language variables is not symmetric, as illustrated below.

@kindex  Uninitialized identifier

@example
pint x, y;
x=5;
x=y*1+2;
@result{} @error{}  id: y
@result{} FATAL: Uninitialized identifier
@end example

@noindent
Meta-language parameter connections correspond to assignment statements.
@sc{Act} permits assigning floating-point values to integer-valued
variables, and vice versa.  However, there are some restrictions on
meta-language variable assignments.

@kindex Setting immutable parameter that has already been set

@example
pint x;
x=5;
x=8;
@result{} @error{}  Id: x
@result{} FATAL: Setting immutable parameter that has already been set
@end example

In this example, @code{x} has been declared and then defined twice at
the top-level of the @sc{act} file. This makes @code{x} a global
variable, which means @code{x} can be used in types defined later in
the @sc{act} file. This potentially makes @code{x} an @dfn{implicit
parameter} for all types, even though @code{x} does not appear in the
template parameter list for any of them. To prevent the situation
where @code{x} might have different values depending on when a type is
used, global parameters can only be defined once in @sc{act}. This
constraint also applies to template parameters for the same reason.

However, for parameters defined within the body of a type, they can be
defined multiple types since they are not in the scope of any other
type. @sc{act} defines global parameter variables and template
parameter variables as @dfn{immutable types}---they can only be
defined once.


@c ------------------------------------------------------------------------

@node Array Connections, User-defined Connections, Simple Connections, Connections
@comment  node-name,  next,  previous,  up

@section Array and Subrange Connections

@cindex connection, array
@cindex array, connection
@cindex connection, subrange
@cindex subrange, connection
@cindex connection, list
@cindex list, connection

Array connections in @sc{Act} are extremely flexible. In general, if
two arrays have the same basic type and have the same number of
elements, they can be connected with a simple connect directive. In the
example below, nodes @code{x[0]}, @dots{}, @code{x[9]} are connected to
nodes @code{y[10]}, @dots{}, @code{y[19]} respectively.

@example
bool x[10];
bool y[10..19];
x=y;
@end example

@noindent
Connecting two arrays of differing sizes is an error.

@kindex Types `@var{type1}' and `@var{type2}' are not compatible

@example
bool x[10];
bool y[10..20];
x=y;
@result{} @error{} Connection: x = y
@result{}  LHS: bool[10]
@result{}  RHS: bool[10..20]
@result{} FATAL: Type-checking failed on connection
@result{}    Types `bool[10]' and `bool[10..20]' are not compatible
@end example

@cindex array, subrange
@sc{Act} provides a @dfn{subrange} mechanism for connecting parts of
arrays to one another. The example below shows a connection between
elements @code{x[3]}, @dots{}, @code{x[7]} to @code{y[12]}, @dots{},
@code{y[16]}.

@example
x[3..7] = y[12..16];
@end example

@noindent
Connections between two arrays with differing numbers of dimensions is
not permitted.

@subsection Array shapes

When a connection between multidimensional arrays is
specified where the shape of the two arrays is not identical, this is
also reported as an error. However, it is possible that two arrays
have the same shape but where the elements have differing indices.  In
this case, the ranges to be connected are sorted in lexicographic
order (with indices closer to the variable having higher weight) and
the corresponding array elements are connected. For example, in the
example below @code{x[3][5]} would be connected to @code{y[0][0]} and
so on.

@example
bool x[3..4][5..6];
bool y[2][2];
x = y;         
@end example

When two arrays are connected by name as in the example above, they
become aliases for each other. So while the connection statement

@example
x[3..4][5..6] = y[0..1][0..1];
@end example

is the same as @code{x=y} earlier, the two are actually logically
different. The first one says that the two arrays are the same, while
the second is an element-by-element connection. This difference is visible in the case of sparse arrays.

@kindex Array being extended after it has participated in a connection
@example
bool x[3..4][5..6];
bool y[2][2];
x = y;
bool x[5..5][5..5];
@result{} @error{} Array being extended after it has participated in a connection
@result{}      Type: bool[ [3..4][5..6]+[5..5][5..5] ]
@end example

In the example above, the arrays @code{x} and @code{y} are connected
to each other. After the connection, the array @code{x} is being
extended in size using the sparse array functionality. This is not
allowed, because this would also make @code{y} a sparse
array---except, the way @code{y} is to be extended is unspecifed. On
the other hand, the same sparse array extension is valid if instead
the element-by-element connection is performed. This is because array
@code{y} has fewer elements compared to @code{x}, and only a subset of
@code{x} is connected to the elements of @code{y}.

Finally, two sparse arrays can be connected to each other as long as
they have the same shape. The shape is determined by viewing a sparse
array as an ordered collection of dense sub-arrays. Two sparse arrays
have the same shape if they have the same number of dense sub-arrays,
and the corresponding dense sub-arrays have the same shape.

Finally, arrays can be re-shaped. The most common example of this is
that a list of variables can be treated as a single array by enclosing
it in braces.

@example
bool x[3];
bool x0,x1,x2;
x = @{x0,x1,x2@};
@end example

This is a special case of a more general mechanism for array
expressions, described next.


@subsection Array Expressions

There are times when it is convenient to ``reshape'' an array, or only
connect part of an array to other instances. @sc{act} provides
flexible syntax to construct arrays from other arrays and instances.

@cindex array expressions

If two arrays have the same dimension, then they can be concatenated
together to form a larger array using the @code{#} operator. In order
to do this, the size of (n-1) dimensions of the arrays must match
(excluding the left-most dimension).

@example
bool x[5];
bool y[3];
bool z[8];

z = x # y; // @r{success!}
@end example

Sometimes it is useful to be able to connect arrays that have
different numbers of dimensions to each other. To change the
dimensionality of an array, the @{ @dots{} @} construct can be used. A
higher-dimensional array can be created by providing a comma-separated
list of lower dimensional arrays enclosed in braces.

@example
bool x[2];
bool y[2];

bool z[2][2];

z = @{x,y@}; // @r{success!}
@end example

In this example, the construct @code{@{x,y@}} is used to create a
two-dimensional array from two one-dimensional arrays. The size and
number of dimensions of all the arrays specified in the list must be
the same. The most common use of this construct is to connect a
one-dimensional array to a list of instances.

A final syntax that is supported for arrays is a mechanism to extract
a sub-array from an array instance. The following example extracts one
row and one column from a two-dimensional array.

@example
bool row[4],col[4];
bool y[4][4];
y[1][0..3]=row;   // @r{connect row}
y[0..3][1]=col;   // @r{connect column}
@end example

In general, array expressions can appear on either the left hand side
or the right hand side of a connection statement. This means that the
following is a valid connection statement:

@example
bool a[2][4];
bool b[4..4][4..7];
bool c0[4],c1[4],c2[4];

@{c0,c1,c2@} = a # b; // @r{success, both sides are} bool[3][4]
@end example


@c ------------------------------------------------------------------------

@node User-defined Connections, Control Flow, Array Connections, Connections    
@comment  node-name,  next,  previous,  up

@section User-defined Type Connections

@cindex connection, user-defined
@cindex type, parameters
@cindex connection, parameters

The result of connecting two user-defined types is to alias the two
instances to each other. A connection is only permitted if the two
types are compatible.

@subsection Connecting identical types

If two variables have identical types, then connecting them to each
other is a simple aliasing operation.

@subsection Connecting types to their implementation

@b{XXX: this section not implemented yet}

If one type is an implementation of a built-in type, then they can be
connected to each other. The combined object corresponds to the
implementation (since the implementation contains strictly more
information). Consider the example below, where @code{d1of2}
implements an @code{int<1>}. 

@example
int<1> x;
d1of2 y;
bool w;

x=y;

y.d0 = w; // @r{success!}
x.d1 = w; // @r{failure}
@end example

While the first connection operation will succeed, the
@code{d0}/@code{d1} fields of the @code{d1of2} implementation are not
accessible through variable @code{x} since @code{x} was declared as
an @code{int<1>}.

However, both @code{x} and @code{y} refer to the same object. For
example, consider the CHP body below that uses @code{x}, @code{y}, and
@code{w}. (Note: the situation we are discussing here is not a
recommended one. It is only being used to illusrate how connections behave.)

@example
chp @{
   x:=1;
   [w->skip [] ~w->x:=0];
@}
@end example

Setting variable @code{x} modifies @code{w}, since @code{y.d0} is
aliased to @code{w} and @code{x} is aliased to @code{y}.

If there are two different implementations of the same type,
attempting to connect them to each other is a type error. Suppose we
have two implementations of an @code{int<2>}: @code{d2x1of2} which
uses two dual-rail codes, and @code{d1of4} which uses a one-of-four
code. Consider the following scenario:

@example
int<2> ivar;
d1of4 x;
d2x1of2 y;
@end example

Now the operation @code{x=ivar}@ is legal, and so is
@code{y=ivar}. However, if both connections are attempted, it is an
error. This is because one cannot connect a @code{d1of4} type to a
@code{d2x1of2} type. This can get confusing, and is a problem for
modular design.

To encapsulate this problem within the definition of a type, we impose
the following constraint: if a port parameter is aliased within the
definition of a type, then the type in the port list must be the most
specific one possible. This prevents this problem from crossing type
definition boundaries.

Connecting subtypes is a bit more complicated, but not that different
from the rules for connecting implementations. Consider the following
situation, where @code{bar} and @code{baz} are both subtypes of @code{foo}.

@example
foo f1;
bar b1;
baz b2;

f1=b1;
f1=b2;
@end example

This would only succeed if there is a @emph{linear} sub-typing
relationship between @code{foo}, @code{bar}, and @code{baz}. In other
words, the connection succeeds if and only if either @code{bar <: baz}
or @code{baz <: bar}, and the the object it represents corresponds to
the most specific type.

If @code{bar} and @code{baz} are not linearly related, the connection
fails even though individually the operations @code{f1=b1} and
@code{f1=b2} would have succeeded. To avoid having this situation
escape type definition boundaries, types used in the port list must be
the most specific ones possible given the body of the type.

@subsection Port connections

When instantiating a variable of a user-defined type, the variables in
the parameter list can be connected to other variables by using a
mechanism akin to parameter passing.

@example
defproc dualrail (bool d0, d1, a)
@{
  spec @{
    exclhi(d0,d1)  // @r{exclusive high directive}
  @}
@}
  
bool d0,d1,da;
dualrail c(d0,d1,da);
@end example

@noindent
In the example above, nodes @code{d0}, @code{d1}, and @code{da} are
connected to @code{c.d0}, @code{c.d1}, and @code{c.da} respectively.
Nodes can be omitted from the connection list. The following statement
connects @code{d1} to @code{c.d1} after instantiating @code{c}.

@example
dualrail c(,d1,);
@end example

Since parameter passing is treated as a connection, all the varied
connection mechanisms are supported in parameter lists as well.

Two other mechanisms for connecting ports are supported. The first
mechanism omits the type name.  The example below is equivalent to the
one we just saw.

@example
dualrail c;

c(,d1,);
@end example

While this may appear to not be useful (since the earlier example is
shorter), it can be helpful in the context of array declarations. For
example, consider the following scenario:

@example
dualrail c[4];
bool d1[4];

(i:4: c[i](,d1[i],); )
@end example

A second mechanism is useful to avoid having to remember the order of
ports in a process definition. Instead of using the port list of the
form where we simply specify the instance to be passed in to the port,
we can instead use the following syntax.

@example
bool d1;
dualrail c(.d1=d1);

dualrail x[4];
bool xd1, xd0;

x[0](.d1=xd1,.d0=xd0);
@end example





@c ------------------------------------------------------------------------
@c   Control flow
@c ------------------------------------------------------------------------

@node  Control Flow,  Loops,  User-defined Connections, Top
@comment  node-name,  next,  previous,  up

@chapter Control Flow 

Complex datapath elements are usually comprised of arrayed versions of
simpler cells. Although arrays can be created directly using arrayed
instantiations, @sc{act} supports looping constructs which can be a
convenient way to create arrayed structures. More complex structures
such as trees can be easily created using recursive instantiations.


@menu
* Loops::               Loops.
* Selections::          Selections.
* Recursion::           Recursion.

@end menu


@node Loops, Selections, Control Flow, Control Flow
@comment  node-name,  next,  previous,  up
@cindex loops
@section Loops

An example of the loop construct in @sc{act} is shown below:

@example
( i : 10 : bool x[i..i]; )
@end example

@noindent The variable @code{i} is the loop index and its scope is
delimited by the angle brackets. The colons separate the different parts
of the loop construct. The number @code{10} is an abbreviation for the
range @code{0..9}. The body of the loop is the statement @code{bool
x[i..i];}. The effect of this statement is the same as

@example
bool x[0..0];
bool x[1..1];
@dots{}
bool x[9..9];
@end example

@noindent
The body of the loop can contain any @sc{act} body, and therefore can
have multiple statements in it. A more common use of the loop statement
is shown below:

@example
register r[1..8];
(i : 1..8 : r[i](in[i],out[i],control); )
@end example

@noindent
In the example above, registers numbered @code{1} through @code{8} are
created. Their first two parameters are connected to the corresponding
elements of arrays @code{in} and @code{out}. However, they have a shared
control that is passed in as the third parameter.

Since loops are part of @sc{act} bodies, they can occur in the body of
another loop. Thus, nested loops are also supported. However, types
cannot be defined in the body of a loop.

A second more general looping construct is borrowed from the guarded
command language.

@example
pint i;
i=0;
*[ i < 10 -> bool x[i..i]; i = i + 1; ]
@end example

This builds an array element by element, using the guarded command
syntax for a general while loop. Note that in this case we are
modifying a @code{pint} variable @code{i}. This sort of construct can
only be used in the body of a type definition, since @code{pint} types
are immutable in global scopes.

The first form of a loop is a special case of syntactic
replication. The general loop syntax can include a @emph{separator},
which is used in other contexts.

In production rule bodies, the loop
@example
(&i:3: x[i])
@end example
expands to
@example
x[0] & x[1] & x[2]
@end example
(notice the absence of a trailing @code{&} is critical for the correct
syntax). The @code{&} symbol separates the body of the loop that is
instantiated for different values of @code{i}. 

@node Selections, Recursion, Loops, Control Flow
@comment  node-name,  next,  previous,  up

@cindex conditionals
@cindex selection statement
@section Selections

Conditional execution is supported by the selection statement. The
syntax of a selection statement is:

@example
[ boolean_expression -> body 
[] boolean_expression -> body
..
]
@end example
The last Boolean expression in the conditional can be the keyword
@code{else}, which is short-hand for ``all other guards are false.''

@noindent
Any one body whose corresponding Boolean expression is true is
executed. For instance, we can create 32 registers with
something special for register 0 as follows:

@example
(i : 32 : 
    [ i = 0 -> r0(in[i],out[i],control)
   [] else -> r[i](in[i],out[i],control)
    ]
)
@end example

Boolean expressions can be constructed from Boolean variables, the
constants @code{true} and @code{false}, and the Boolean operators
@code{&}, @code{|}, and @code{~} denoting the and, or, and negation
operations respectively.  Numeric expressions can be compared using
@code{<}, @code{<=}, @code{>}, @code{>=}, @code{=}, and @code{!=} for
the operators less than, less than or equal to, greater than, greater
than or equal to, equal to, and not equal to respectively.

@node Recursion, Namespaces, Selections, Control Flow
@comment  node-name,  next,  previous,  up
@cindex recursion
@section Recursion

Type definitions can be recursive. For instance, the following
definition can be used to create a tree structure.

@example
template<pint N>
defproc tree (bool a[N])
@{
  [ N = 1 -> leaf l(a[0]) 
 [] N > 1 -> tree<N/2> t0(a[0..N/2-1]);
             tree<N-N/2> t1(a[N/2..N-1])
  ]
@}
@end example

@c ------------------------------------------------------------------------
@c   Namespaces
@c ------------------------------------------------------------------------
@node Namespaces, Languages, Recursion, Top
@comment  node-name,  next,  previous,  up

@chapter Namespaces

@cindex namespaces

Namespaces are used as a mechanism to prevent naming conflicts when
multiple people are working on a design. While @sc{act} can be used
without any namespaces (in which case everything is defined and
created in the default namespace @code{Global}), most large designs
will contain structure that can be used to keep the @sc{act} files
clean and modular.

@section Creating a Namespace

A namespace is created by using the @code{namespace} construct.

@example
namespace lib @{
@dots{}
export defproc buffer (a1of2? l; a1of2! r) @{ @dots{} @}
@dots{}
@}
@end example

The process @code{buffer} has been created in the namespace
@code{lib}, and it's fully qualified name is
@code{::lib::buffer}. This syntax is similar to the one used by
C++.

An @sc{act} type or instance is first evaluated in the current
namespace; if it doesn't exist in the current namespace, then the
global namespace is searched next.

A namespace typically contains user-defined types. By default, these
types are only visible within the current namespace. To allow a type
to be visible in any other namespace, it must be prefaced by the
@code{export} keyword (as above).

A namespace can also contain another namespace. However, these
namespaces do not have special privileges. An example of nested
namespaces is shown below.

@example
namespace datapath @{
    export defproc bus_interface(@dots{}) @{ @dots{} @}
    namespace adder @{
      export defproc alu(@dots{}) @{
        bus_interface b;
      @}
    @}
    @dots{}
@}
@end example

Nesting does not give a namespace special permissions; if the
@code{bus_interface} definition was not @code{export}ed, then the
namespace @code{adder} within it would not be able to reference
@code{bus_interface}. However, notice that the type
@code{bus_interface} within @code{alu} did not require its fully
qualified name, due to the fact that the definition is in scope due to
nesting.

@code{alu} cannot be referenced from the global namespace using
@code{datapath::adder::alu}. Although @code{alu} is exported from the
namespace @code{datapath::adder}, the @code{export} directive only
exports the definition one level up. To export this another level out,
the entire namespace @code{adder} can be exported as follows:

@example
namespace datapath @{
    export defproc bus_interface(@dots{}) @{ @dots{} @}
    export namespace adder @{
      export defproc alu(@dots{}) @{
        bus_interface b;
      @}
    @}
    @dots{}
@}
@end example

Now @code{datapath::adder::alu} can be accessed from the global
namespace.

@dfn{Namespace globals} are instances that are defined outside any type
definition. While the @code{Global} namespace can have any instances
or other constructs used to construct circuits, other namespaces can
only have global data types or channels---i.e. no circuits.

@section Importing Namespaces

Importing.

@section Opening Namespaces

Open syntax: two flavors!

Raw and renaming.



@c ------------------------------------------------------------------------
@c   Language-specific information goes here
@c ------------------------------------------------------------------------

@node Languages, API, Namespaces, Top
@comment  node-name,  next,  previous,  up

@chapter Hardware description languges

Circuits in the body of an @sc{act} process are specified using a
number of different languages. Each language specifies the circuit at
a different level of abstraction.

@section CHP Language

The @code{chp} language.

@section HSE Language

The @code{hse} language.

@section Production rules

The @code{prs} language

@subsection Basic syntax

Implicit gate ordering.

@subsection Syntactic replication

@subsection Transistor conversion

@subsection Trees and shared gate networks

@subsection Internal precharge

@subsection Directives

@section Specifications

The @code{spec} language.


@node API, BNF, Languages, Top
@comment  node-name,  next,  previous,  up

@chapter API to the library

There are two basic data structures created by the @sc{act} library:

@itemize @bullet
@item @emph{Unexpanded} data structures correspond to a representation
of the @sc{act} input. This primarily consists of namespaces and type
definitions, along with top-level instances in each namespace.
@item @emph{Expanded} data structures correspond to the @sc{act} file
specialized with all parameters expanded out.
@end itemize

The @code{Act} class is used to read in @sc{act} files, and expand all
template parameters. Reading in the file performs a number of static
checks, verifying that the input is valid. Not all the checks can be
performed when a file is just read in; for example, it may not be
possible to verify that an array access is valid because array bounds
checks can depend on the values of parameters. Expanding the input
performs the checks that might need parameter values, in addition to
creating expanded data structures.

@example
Act *a = new Act ("test.act"); // creates unexpanded data structures
a->Expand(); // creates expanded data structures
@end example

@section Namespaces

The contents of the @sc{act} file are accessed through the global
namespace. Each namespace contains:

@itemize @bullet
@item A set of namespaces within it (nested namespaces);
@item A set of types defined within the namespace;
@item A set of expanded types (if any);
@item The body of the namespace;
@item A @code{Scope}, used to create and represent the identifiers
created within the namespace.
@end itemize

@subsection Scope

Within a scope, we have per-scope values (parameters). We don't have
per instance values here. 


@c -----------------------------------------------------------------------
@c  BNF for language
@c -----------------------------------------------------------------------

@node BNF,  Errors and Warnings, Languages, Top
@comment  node-name,  next,  previous,  up

@appendix BNF for the @sc{act} language
@cindex @sc{act}, BNF
@cindex BNF, @sc{act}

@include bnf.texinfo

@appendix BNF for @code{prs} bodies


@c ------------------------------------------------------------------------
@c     Table of warnings and errors
@c ------------------------------------------------------------------------

@node Errors and Warnings,  Function Index, BNF, Top
@comment  node-name,  next,  previous,  up

@unnumbered Warning and Error messages

Warning and error messages are generated by @sc{act} when parsing the
input as well as when expanding the @sc{act} hierarchy. Typically, any
error that can be checked statically is checked at parse time. All other
errors are reported when flattening the @sc{act} hierarchy. When an
error is reported, some feedback regarding where the error occurred is
provided. Parse errors include the file name and line number where the
error occurred. Errors reported when flattening the hierarchy (such as
array bounds errors) include the name of the instance variable and the
type being instantiated when the error occurred.

@printindex ky

@c ------------------------------------------------------------------------
@c     Function Index
@c ------------------------------------------------------------------------

@node Function Index,  Concept Index, Errors and Warnings, Top
@comment  node-name,  next,  previous,  up

@unnumbered Function Index

@printindex fn

@c ------------------------------------------------------------------------
@c     Concept Index
@c ------------------------------------------------------------------------

@node  Concept Index,  , Function Index, Top

@unnumbered Concept Index

@printindex cp

@bye
